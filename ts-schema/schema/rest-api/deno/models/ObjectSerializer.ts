export * from './Agent.ts';
export * from './AgentLocator.ts';
export * from './AgentPool.ts';
export * from './AgentPoolLocator.ts';
export * from './AgentPools.ts';
export * from './AgentRequirement.ts';
export * from './AgentRequirements.ts';
export * from './Agents.ts';
export * from './ArtifactDependencies.ts';
export * from './ArtifactDependency.ts';
export * from './AuditAction.ts';
export * from './AuditEvent.ts';
export * from './AuditEvents.ts';
export * from './AuditLocator.ts';
export * from './AuthorizedInfo.ts';
export * from './Branch.ts';
export * from './BranchLocator.ts';
export * from './BranchVersion.ts';
export * from './Branches.ts';
export * from './Build.ts';
export * from './BuildCancelRequest.ts';
export * from './BuildChange.ts';
export * from './BuildChanges.ts';
export * from './BuildLocator.ts';
export * from './BuildQueueLocator.ts';
export * from './BuildTriggeringOptions.ts';
export * from './BuildType.ts';
export * from './BuildTypeLocator.ts';
export * from './BuildTypes.ts';
export * from './Builds.ts';
export * from './Change.ts';
export * from './ChangeLocator.ts';
export * from './Changes.ts';
export * from './CloudImage.ts';
export * from './CloudImages.ts';
export * from './CloudInstance.ts';
export * from './CloudInstances.ts';
export * from './CloudProfile.ts';
export * from './CloudProfiles.ts';
export * from './Comment.ts';
export * from './Compatibilities.ts';
export * from './Compatibility.ts';
export * from './CompatibilityPolicy.ts';
export * from './Customizations.ts';
export * from './Datas.ts';
export * from './EnabledInfo.ts';
export * from './Entries.ts';
export * from './Entry.ts';
export * from './Environment.ts';
export * from './Feature.ts';
export * from './Features.ts';
export * from './File.ts';
export * from './FileChange.ts';
export * from './FileChanges.ts';
export * from './Files.ts';
export * from './Group.ts';
export * from './Groups.ts';
export * from './Href.ts';
export * from './Investigation.ts';
export * from './InvestigationLocator.ts';
export * from './Investigations.ts';
export * from './Issue.ts';
export * from './IssueUsage.ts';
export * from './Issues.ts';
export * from './IssuesUsages.ts';
export * from './Items.ts';
export * from './LicenseKey.ts';
export * from './LicenseKeys.ts';
export * from './LicensingData.ts';
export * from './Link.ts';
export * from './Links.ts';
export * from './MetaData.ts';
export * from './Metric.ts';
export * from './MetricTag.ts';
export * from './MetricTags.ts';
export * from './MetricValue.ts';
export * from './MetricValues.ts';
export * from './Metrics.ts';
export * from './MultipleOperationResult.ts';
export * from './Mute.ts';
export * from './MuteLocator.ts';
export * from './Mutes.ts';
export * from './NewBuildTypeDescription.ts';
export * from './NewProjectDescription.ts';
export * from './OperationResult.ts';
export * from './ParsedTestName.ts';
export * from './Permission.ts';
export * from './PermissionAssignment.ts';
export * from './PermissionAssignments.ts';
export * from './PermissionRestriction.ts';
export * from './PermissionRestrictions.ts';
export * from './PinInfo.ts';
export * from './Plugin.ts';
export * from './Plugins.ts';
export * from './Problem.ts';
export * from './ProblemLocator.ts';
export * from './ProblemOccurrence.ts';
export * from './ProblemOccurrenceLocator.ts';
export * from './ProblemOccurrences.ts';
export * from './ProblemScope.ts';
export * from './ProblemTarget.ts';
export * from './Problems.ts';
export * from './ProgressInfo.ts';
export * from './Project.ts';
export * from './ProjectFeature.ts';
export * from './ProjectFeatures.ts';
export * from './ProjectLocator.ts';
export * from './Projects.ts';
export * from './Properties.ts';
export * from './Property.ts';
export * from './Related.ts';
export * from './RelatedEntities.ts';
export * from './RelatedEntity.ts';
export * from './RepositoryState.ts';
export * from './Requirements.ts';
export * from './Resolution.ts';
export * from './Revision.ts';
export * from './Revisions.ts';
export * from './Role.ts';
export * from './Roles.ts';
export * from './Server.ts';
export * from './SnapshotDependencies.ts';
export * from './SnapshotDependency.ts';
export * from './StateField.ts';
export * from './Step.ts';
export * from './Steps.ts';
export * from './Tag.ts';
export * from './TagLocator.ts';
export * from './Tags.ts';
export * from './Test.ts';
export * from './TestCounters.ts';
export * from './TestLocator.ts';
export * from './TestOccurrence.ts';
export * from './TestOccurrenceLocator.ts';
export * from './TestOccurrences.ts';
export * from './TestRunMetadata.ts';
export * from './Tests.ts';
export * from './Token.ts';
export * from './Tokens.ts';
export * from './Trigger.ts';
export * from './TriggeredBy.ts';
export * from './Triggers.ts';
export * from './Type.ts';
export * from './TypedValue.ts';
export * from './User.ts';
export * from './UserGroupLocator.ts';
export * from './UserLocator.ts';
export * from './Users.ts';
export * from './VcsCheckStatus.ts';
export * from './VcsLabel.ts';
export * from './VcsLabels.ts';
export * from './VcsRoot.ts';
export * from './VcsRootEntries.ts';
export * from './VcsRootEntry.ts';
export * from './VcsRootInstance.ts';
export * from './VcsRootInstanceLocator.ts';
export * from './VcsRootInstances.ts';
export * from './VcsRootLocator.ts';
export * from './VcsRoots.ts';
export * from './VcsStatus.ts';

import { Agent } from './Agent.ts';
import { AgentLocator } from './AgentLocator.ts';
import { AgentPool } from './AgentPool.ts';
import { AgentPoolLocator } from './AgentPoolLocator.ts';
import { AgentPools } from './AgentPools.ts';
import { AgentRequirement } from './AgentRequirement.ts';
import { AgentRequirements } from './AgentRequirements.ts';
import { Agents } from './Agents.ts';
import { ArtifactDependencies } from './ArtifactDependencies.ts';
import { ArtifactDependency } from './ArtifactDependency.ts';
import { AuditAction } from './AuditAction.ts';
import { AuditEvent } from './AuditEvent.ts';
import { AuditEvents } from './AuditEvents.ts';
import { AuditLocator } from './AuditLocator.ts';
import { AuthorizedInfo } from './AuthorizedInfo.ts';
import { Branch } from './Branch.ts';
import { BranchLocator } from './BranchLocator.ts';
import { BranchVersion } from './BranchVersion.ts';
import { Branches } from './Branches.ts';
import { Build } from './Build.ts';
import { BuildCancelRequest } from './BuildCancelRequest.ts';
import { BuildChange } from './BuildChange.ts';
import { BuildChanges } from './BuildChanges.ts';
import { BuildLocator } from './BuildLocator.ts';
import { BuildQueueLocator } from './BuildQueueLocator.ts';
import { BuildTriggeringOptions } from './BuildTriggeringOptions.ts';
import { BuildType } from './BuildType.ts';
import { BuildTypeLocator } from './BuildTypeLocator.ts';
import { BuildTypes } from './BuildTypes.ts';
import { Builds } from './Builds.ts';
import { Change } from './Change.ts';
import { ChangeLocator } from './ChangeLocator.ts';
import { Changes } from './Changes.ts';
import { CloudImage } from './CloudImage.ts';
import { CloudImages } from './CloudImages.ts';
import { CloudInstance } from './CloudInstance.ts';
import { CloudInstances } from './CloudInstances.ts';
import { CloudProfile } from './CloudProfile.ts';
import { CloudProfiles } from './CloudProfiles.ts';
import { Comment } from './Comment.ts';
import { Compatibilities } from './Compatibilities.ts';
import { Compatibility } from './Compatibility.ts';
import { CompatibilityPolicy } from './CompatibilityPolicy.ts';
import { Customizations } from './Customizations.ts';
import { Datas } from './Datas.ts';
import { EnabledInfo } from './EnabledInfo.ts';
import { Entries } from './Entries.ts';
import { Entry } from './Entry.ts';
import { Environment } from './Environment.ts';
import { Feature } from './Feature.ts';
import { Features } from './Features.ts';
import { File } from './File.ts';
import { FileChange } from './FileChange.ts';
import { FileChanges } from './FileChanges.ts';
import { Files } from './Files.ts';
import { Group } from './Group.ts';
import { Groups } from './Groups.ts';
import { Href } from './Href.ts';
import { Investigation } from './Investigation.ts';
import { InvestigationLocator } from './InvestigationLocator.ts';
import { Investigations } from './Investigations.ts';
import { Issue } from './Issue.ts';
import { IssueUsage } from './IssueUsage.ts';
import { Issues } from './Issues.ts';
import { IssuesUsages } from './IssuesUsages.ts';
import { Items } from './Items.ts';
import { LicenseKey } from './LicenseKey.ts';
import { LicenseKeys } from './LicenseKeys.ts';
import { LicensingData } from './LicensingData.ts';
import { Link } from './Link.ts';
import { Links } from './Links.ts';
import { MetaData } from './MetaData.ts';
import { Metric } from './Metric.ts';
import { MetricTag } from './MetricTag.ts';
import { MetricTags } from './MetricTags.ts';
import { MetricValue } from './MetricValue.ts';
import { MetricValues } from './MetricValues.ts';
import { Metrics } from './Metrics.ts';
import { MultipleOperationResult } from './MultipleOperationResult.ts';
import { Mute } from './Mute.ts';
import { MuteLocator } from './MuteLocator.ts';
import { Mutes } from './Mutes.ts';
import { NewBuildTypeDescription } from './NewBuildTypeDescription.ts';
import { NewProjectDescription } from './NewProjectDescription.ts';
import { OperationResult } from './OperationResult.ts';
import { ParsedTestName } from './ParsedTestName.ts';
import { Permission } from './Permission.ts';
import { PermissionAssignment } from './PermissionAssignment.ts';
import { PermissionAssignments } from './PermissionAssignments.ts';
import { PermissionRestriction } from './PermissionRestriction.ts';
import { PermissionRestrictions } from './PermissionRestrictions.ts';
import { PinInfo } from './PinInfo.ts';
import { Plugin } from './Plugin.ts';
import { Plugins } from './Plugins.ts';
import { Problem } from './Problem.ts';
import { ProblemLocator } from './ProblemLocator.ts';
import { ProblemOccurrence } from './ProblemOccurrence.ts';
import { ProblemOccurrenceLocator } from './ProblemOccurrenceLocator.ts';
import { ProblemOccurrences } from './ProblemOccurrences.ts';
import { ProblemScope } from './ProblemScope.ts';
import { ProblemTarget } from './ProblemTarget.ts';
import { Problems } from './Problems.ts';
import { ProgressInfo } from './ProgressInfo.ts';
import { Project } from './Project.ts';
import { ProjectFeature } from './ProjectFeature.ts';
import { ProjectFeatures } from './ProjectFeatures.ts';
import { ProjectLocator } from './ProjectLocator.ts';
import { Projects } from './Projects.ts';
import { Properties } from './Properties.ts';
import { Property } from './Property.ts';
import { Related } from './Related.ts';
import { RelatedEntities } from './RelatedEntities.ts';
import { RelatedEntity } from './RelatedEntity.ts';
import { RepositoryState } from './RepositoryState.ts';
import { Requirements } from './Requirements.ts';
import { Resolution } from './Resolution.ts';
import { Revision } from './Revision.ts';
import { Revisions } from './Revisions.ts';
import { Role } from './Role.ts';
import { Roles } from './Roles.ts';
import { Server } from './Server.ts';
import { SnapshotDependencies } from './SnapshotDependencies.ts';
import { SnapshotDependency } from './SnapshotDependency.ts';
import { StateField } from './StateField.ts';
import { Step } from './Step.ts';
import { Steps } from './Steps.ts';
import { Tag } from './Tag.ts';
import { TagLocator } from './TagLocator.ts';
import { Tags } from './Tags.ts';
import { Test } from './Test.ts';
import { TestCounters } from './TestCounters.ts';
import { TestLocator } from './TestLocator.ts';
import { TestOccurrence } from './TestOccurrence.ts';
import { TestOccurrenceLocator } from './TestOccurrenceLocator.ts';
import { TestOccurrences } from './TestOccurrences.ts';
import { TestRunMetadata } from './TestRunMetadata.ts';
import { Tests } from './Tests.ts';
import { Token } from './Token.ts';
import { Tokens } from './Tokens.ts';
import { Trigger } from './Trigger.ts';
import { TriggeredBy } from './TriggeredBy.ts';
import { Triggers } from './Triggers.ts';
import { Type } from './Type.ts';
import { TypedValue } from './TypedValue.ts';
import { User } from './User.ts';
import { UserGroupLocator } from './UserGroupLocator.ts';
import { UserLocator } from './UserLocator.ts';
import { Users } from './Users.ts';
import { VcsCheckStatus } from './VcsCheckStatus.ts';
import { VcsLabel } from './VcsLabel.ts';
import { VcsLabels } from './VcsLabels.ts';
import { VcsRoot } from './VcsRoot.ts';
import { VcsRootEntries } from './VcsRootEntries.ts';
import { VcsRootEntry } from './VcsRootEntry.ts';
import { VcsRootInstance } from './VcsRootInstance.ts';
import { VcsRootInstanceLocator } from './VcsRootInstanceLocator.ts';
import { VcsRootInstances } from './VcsRootInstances.ts';
import { VcsRootLocator } from './VcsRootLocator.ts';
import { VcsRoots } from './VcsRoots.ts';
import { VcsStatus } from './VcsStatus.ts';

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

const supportedMediaTypes: { [mediaType: string]: number } = {
  "application/json": Infinity,
  "application/octet-stream": 0
}

                 
let enumsMap: Set<string> = new Set<string>([
]);

let typeMap: {[index: string]: any} = {
    "Agent": Agent,
    "AgentLocator": AgentLocator,
    "AgentPool": AgentPool,
    "AgentPoolLocator": AgentPoolLocator,
    "AgentPools": AgentPools,
    "AgentRequirement": AgentRequirement,
    "AgentRequirements": AgentRequirements,
    "Agents": Agents,
    "ArtifactDependencies": ArtifactDependencies,
    "ArtifactDependency": ArtifactDependency,
    "AuditAction": AuditAction,
    "AuditEvent": AuditEvent,
    "AuditEvents": AuditEvents,
    "AuditLocator": AuditLocator,
    "AuthorizedInfo": AuthorizedInfo,
    "Branch": Branch,
    "BranchLocator": BranchLocator,
    "BranchVersion": BranchVersion,
    "Branches": Branches,
    "Build": Build,
    "BuildCancelRequest": BuildCancelRequest,
    "BuildChange": BuildChange,
    "BuildChanges": BuildChanges,
    "BuildLocator": BuildLocator,
    "BuildQueueLocator": BuildQueueLocator,
    "BuildTriggeringOptions": BuildTriggeringOptions,
    "BuildType": BuildType,
    "BuildTypeLocator": BuildTypeLocator,
    "BuildTypes": BuildTypes,
    "Builds": Builds,
    "Change": Change,
    "ChangeLocator": ChangeLocator,
    "Changes": Changes,
    "CloudImage": CloudImage,
    "CloudImages": CloudImages,
    "CloudInstance": CloudInstance,
    "CloudInstances": CloudInstances,
    "CloudProfile": CloudProfile,
    "CloudProfiles": CloudProfiles,
    "Comment": Comment,
    "Compatibilities": Compatibilities,
    "Compatibility": Compatibility,
    "CompatibilityPolicy": CompatibilityPolicy,
    "Customizations": Customizations,
    "Datas": Datas,
    "EnabledInfo": EnabledInfo,
    "Entries": Entries,
    "Entry": Entry,
    "Environment": Environment,
    "Feature": Feature,
    "Features": Features,
    "File": File,
    "FileChange": FileChange,
    "FileChanges": FileChanges,
    "Files": Files,
    "Group": Group,
    "Groups": Groups,
    "Href": Href,
    "Investigation": Investigation,
    "InvestigationLocator": InvestigationLocator,
    "Investigations": Investigations,
    "Issue": Issue,
    "IssueUsage": IssueUsage,
    "Issues": Issues,
    "IssuesUsages": IssuesUsages,
    "Items": Items,
    "LicenseKey": LicenseKey,
    "LicenseKeys": LicenseKeys,
    "LicensingData": LicensingData,
    "Link": Link,
    "Links": Links,
    "MetaData": MetaData,
    "Metric": Metric,
    "MetricTag": MetricTag,
    "MetricTags": MetricTags,
    "MetricValue": MetricValue,
    "MetricValues": MetricValues,
    "Metrics": Metrics,
    "MultipleOperationResult": MultipleOperationResult,
    "Mute": Mute,
    "MuteLocator": MuteLocator,
    "Mutes": Mutes,
    "NewBuildTypeDescription": NewBuildTypeDescription,
    "NewProjectDescription": NewProjectDescription,
    "OperationResult": OperationResult,
    "ParsedTestName": ParsedTestName,
    "Permission": Permission,
    "PermissionAssignment": PermissionAssignment,
    "PermissionAssignments": PermissionAssignments,
    "PermissionRestriction": PermissionRestriction,
    "PermissionRestrictions": PermissionRestrictions,
    "PinInfo": PinInfo,
    "Plugin": Plugin,
    "Plugins": Plugins,
    "Problem": Problem,
    "ProblemLocator": ProblemLocator,
    "ProblemOccurrence": ProblemOccurrence,
    "ProblemOccurrenceLocator": ProblemOccurrenceLocator,
    "ProblemOccurrences": ProblemOccurrences,
    "ProblemScope": ProblemScope,
    "ProblemTarget": ProblemTarget,
    "Problems": Problems,
    "ProgressInfo": ProgressInfo,
    "Project": Project,
    "ProjectFeature": ProjectFeature,
    "ProjectFeatures": ProjectFeatures,
    "ProjectLocator": ProjectLocator,
    "Projects": Projects,
    "Properties": Properties,
    "Property": Property,
    "Related": Related,
    "RelatedEntities": RelatedEntities,
    "RelatedEntity": RelatedEntity,
    "RepositoryState": RepositoryState,
    "Requirements": Requirements,
    "Resolution": Resolution,
    "Revision": Revision,
    "Revisions": Revisions,
    "Role": Role,
    "Roles": Roles,
    "Server": Server,
    "SnapshotDependencies": SnapshotDependencies,
    "SnapshotDependency": SnapshotDependency,
    "StateField": StateField,
    "Step": Step,
    "Steps": Steps,
    "Tag": Tag,
    "TagLocator": TagLocator,
    "Tags": Tags,
    "Test": Test,
    "TestCounters": TestCounters,
    "TestLocator": TestLocator,
    "TestOccurrence": TestOccurrence,
    "TestOccurrenceLocator": TestOccurrenceLocator,
    "TestOccurrences": TestOccurrences,
    "TestRunMetadata": TestRunMetadata,
    "Tests": Tests,
    "Token": Token,
    "Tokens": Tokens,
    "Trigger": Trigger,
    "TriggeredBy": TriggeredBy,
    "Triggers": Triggers,
    "Type": Type,
    "TypedValue": TypedValue,
    "User": User,
    "UserGroupLocator": UserGroupLocator,
    "UserLocator": UserLocator,
    "Users": Users,
    "VcsCheckStatus": VcsCheckStatus,
    "VcsLabel": VcsLabel,
    "VcsLabels": VcsLabels,
    "VcsRoot": VcsRoot,
    "VcsRootEntries": VcsRootEntries,
    "VcsRootEntry": VcsRootEntry,
    "VcsRootInstance": VcsRootInstance,
    "VcsRootInstanceLocator": VcsRootInstanceLocator,
    "VcsRootInstances": VcsRootInstances,
    "VcsRootLocator": VcsRootLocator,
    "VcsRoots": VcsRoots,
    "VcsStatus": VcsStatus,
}

export class ObjectSerializer {
    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    if(typeMap[discriminatorType]){
                        return discriminatorType; // use the type given in the discriminator
                    } else {
                        return expectedType; // discriminator did not map to a type
                    }
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string, format: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth()+1
                month = month < 10 ? "0" + month.toString() : month.toString()
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();

                return data.getFullYear() + "-" + month + "-" + day;
            } else {
                return data.toISOString();
            }
        } else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            
            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap.has(type)) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }


    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    public static normalizeMediaType(mediaType: string | undefined): string | undefined {
        if (mediaType === undefined) {
            return undefined;
        }
        return mediaType.split(";")[0].trim().toLowerCase();
    }

    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    public static getPreferredMediaType(mediaTypes: Array<string>): string {
        /** According to OAS 3 we should default to json */
        if (!mediaTypes) {
            return "application/json";
        }

        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
        let selectedMediaType: string | undefined = undefined;
        let selectedRank: number = -Infinity;
        for (const mediaType of normalMediaTypes) {
            if (supportedMediaTypes[mediaType!] > selectedRank) {
                selectedMediaType = mediaType;
                selectedRank = supportedMediaTypes[mediaType!];
            }
        }

        if (selectedMediaType === undefined) {
            throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
        }

        return selectedMediaType!;
    }

    /**
     * Convert data to a string according the given media type
     */
    public static stringify(data: any, mediaType: string): string {
        if (mediaType === "application/json") {
            return JSON.stringify(data);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }

    /**
     * Parse data from a string according to the given media type
     */
    public static parse(rawData: string, mediaType: string | undefined) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }

        if (mediaType === "application/json") {
            return JSON.parse(rawData);
        }

        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
